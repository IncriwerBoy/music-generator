import numpy as np
from IPython.display import Audio, display
import os
import sys
from music21 import converter, instrument, note, chord, stream
from src.utils import load_object, int_to_note
from src.components.model_trainer import ModelStructure
from keras.models import load_model
from src.exception import CustomException

class GenerationPipeline:
    def __init__(self):
        pass
    
    def pattern_creation(self):
        net_input = load_object("../artifacts/net_input.pkl")
        in_len = len(net_input)
        pitch_name = load_object("../artifacts/pitchnames.pkl")
        n_vocab = len(pitch_name)
        
        prediction_output = []
        
        start = np.random.randint(0, in_len-1)
        pattern = net_input[start]
        
        model_obj = ModelStructure()
        model = model_obj.model_build(input_shape=(100,1), n_vocab=n_vocab)
        model = load_model('../artifacts/model.h5')
        
        # generate 500 notes
        for note_index in range(500):
            prediction_input = np.reshape(pattern, (1, len(pattern), 1))
            prediction_input = prediction_input / float(n_vocab)

            prediction = model.predict(prediction_input, verbose=0)

            index = np.argmax(prediction)
            int_noted = int_to_note(pitch_name)
            result = int_noted[index]
            prediction_output.append(result)
            pattern= np.append(pattern, index)
            pattern = pattern[1:len(pattern)]
        
        return prediction_output
    
    def generate_music(self):
        try:
            prediction_output = self.pattern_creation()
            
            offset = 0
            output_notes = []

            # create note and chord objects based on the values generated by the model
            for pattern in prediction_output:
            #pattern is a chord
                if ('.' in pattern) or pattern.isdigit():
                    notes_in_chord = pattern.split('.')
                    notes = []
                    for current_note in notes_in_chord:
                        new_note = note.Note(int(current_note))
                        new_note.storedInstrument = instrument.Piano()
                        notes.append(new_note)
                    new_chord = chord.Chord(notes)
                    new_chord.offset = offset
                    output_notes.append(new_chord)

                #pattern is a note
                else:
                    new_note = note.Note(pattern)
                    new_note.offset = offset
                    new_note.storedInstrument = instrument.Piano()
                    output_notes.append(new_note)

                # increase offset each iteration so that notes do not stack
                offset += 0.5
            
            midi_file = '/artifacts/test_output.mid'
            midi_stream = stream.Stream(output_notes)
            midi_stream.write('midi', fp=midi_file)
        
        except Exception as e:
            raise CustomException(e, sys)
        
        return midi_file


if __name__ == '__main__':
    generation_pipeline_obj = GenerationPipeline()
    midi_file = generation_pipeline_obj.generate_music()
    display(Audio(midi_file))